// knn_location_risk.cpp
// K-Nearest Neighbors for classifying a location as Safe or Risky
// Compile: g++ -std=c++17 -O2 -o knn_location_risk knn_location_risk.cpp
//
// The program reads a CSV of historical reports with columns:
// report_id,latitude,longitude,label,severity,timestamp
//
// Example usage:
// ./knn_location_risk crime_reports.csv --mode bruteforce --k 7 --query 12.9716 77.5946
//
// The program prints "Risky" or "Safe" for the query location and details.
//
// Author: generated by ChatGPT

#include <bits/stdc++.h>
using namespace std;

// --------------------------- Utilities ------------------------------------

static inline void trim(string &s) {
    const char* ws = " \t\r\n";
    size_t a = s.find_first_not_of(ws);
    if (a == string::npos) { s.clear(); return; }
    size_t b = s.find_last_not_of(ws);
    s = s.substr(a, b - a + 1);
}

bool parse_csv_line(const string &line, vector<string> &out) {
    out.clear();
    string cur;
    for (char ch : line) {
        if (ch == ',') {
            trim(cur);
            out.push_back(cur);
            cur.clear();
        } else {
            cur.push_back(ch);
        }
    }
    trim(cur);
    out.push_back(cur);
    return true;
}

double deg2rad(double deg) { return deg * M_PI / 180.0; }

// Haversine formula returns distance in meters (approx)
double haversine_distance_m(double lat1, double lon1, double lat2, double lon2) {
    // Earth radius in meters
    const double R = 6371000.0;
    double dlat = deg2rad(lat2 - lat1);
    double dlon = deg2rad(lon2 - lon1);
    double a = sin(dlat/2.0) * sin(dlat/2.0) +
               cos(deg2rad(lat1)) * cos(deg2rad(lat2)) *
               sin(dlon/2.0) * sin(dlon/2.0);
    double c = 2.0 * atan2(sqrt(a), sqrt(max(0.0,1.0-a)));
    return R * c;
}

// --------------------------- Data Structures -------------------------------

struct Point {
    string id;
    double lat;
    double lon;
    int label;      // 1 = Risky, 0 = Safe
    int severity;   // optional additional feature
    long timestamp; // optional
};

struct Neighbor {
    double dist; // in meters
    int label;
    string id;
    bool operator<(const Neighbor &o) const {
        return dist < o.dist;
    }
};

// --------------------------- Brute-force KNN -------------------------------

// Return K nearest neighbors (unsorted or sorted) using nth_element for speed.
vector<Neighbor> knn_bruteforce(const vector<Point> &data, double qlat, double qlon, int K) {
    int N = (int)data.size();
    vector<Neighbor> arr;
    arr.reserve(N);
    for (const auto &p : data) {
        double d = haversine_distance_m(qlat, qlon, p.lat, p.lon);
        arr.push_back({d, p.label, p.id});
    }
    if (K >= N) {
        sort(arr.begin(), arr.end(), [](const Neighbor &a, const Neighbor &b){ return a.dist < b.dist; });
        return arr;
    }
    // Use nth_element to get K smallest in O(N)
    nth_element(arr.begin(), arr.begin() + K, arr.end(), [](const Neighbor &a, const Neighbor &b){ return a.dist < b.dist; });
    arr.resize(K);
    sort(arr.begin(), arr.end(), [](const Neighbor &a, const Neighbor &b){ return a.dist < b.dist; });
    return arr;
}

// Weighted voting using inverse distance (with epsilon)
double weighted_vote(const vector<Neighbor> &neighbors, double eps = 1e-6) {
    double sum_w_risky = 0.0;
    double sum_w_total = 0.0;
    for (const auto &n : neighbors) {
        double w = 1.0 / (n.dist + eps); // inverse distance weight
        sum_w_total += w;
        if (n.label == 1) sum_w_risky += w;
    }
    if (sum_w_total <= 0) return 0.0;
    return sum_w_risky / sum_w_total; // proportion weighted
}

// Simple majority vote
int majority_vote(const vector<Neighbor> &neighbors) {
    int cntRisk = 0;
    for (const auto &n : neighbors) if (n.label == 1) ++cntRisk;
    return (cntRisk * 2 >= (int)neighbors.size()) ? 1 : 0; // tie -> risky
}

// --------------------------- KD-Tree (2D) ---------------------------------
// Simple KD-tree implementation for 2D points (latitude, longitude).
// This is a recursive median-splitting KD-tree; supports KNN search.
// Note: For production use, prefer a well-tested library (nanoflann, FLANN, etc.).

struct KDNode {
    int idx; // index in original data vector
    int axis; // 0 = lat, 1 = lon
    KDNode *left;
    KDNode *right;
    KDNode(int i= -1, int a=0): idx(i), axis(a), left(nullptr), right(nullptr) {}
};

struct KDTree {
    const vector<Point> *data;
    KDNode *root;
    KDTree(): data(nullptr), root(nullptr) {}
    ~KDTree() { clear(root); }
    void clear(KDNode *node) {
        if (!node) return;
        clear(node->left);
        clear(node->right);
        delete node;
    }

    // Build indices list and recursively build
    KDNode* build_recursive(vector<int> &idxs, int l, int r, int depth) {
        if (l >= r) return nullptr;
        int axis = depth % 2;
        int m = (l + r) / 2;
        auto comparator = [&](int a, int b) {
            if (axis == 0) return data->at(a).lat < data->at(b).lat;
            return data->at(a).lon < data->at(b).lon;
        };
        nth_element(idxs.begin()+l, idxs.begin()+m, idxs.begin()+r, comparator);
        KDNode *node = new KDNode(idxs[m], axis);
        node->left = build_recursive(idxs, l, m, depth+1);
        node->right = build_recursive(idxs, m+1, r, depth+1);
        return node;
    }

    void build(const vector<Point> &pts) {
        data = &pts;
        int n = (int)pts.size();
        vector<int> idxs(n);
        iota(idxs.begin(), idxs.end(), 0);
        root = build_recursive(idxs, 0, n, 0);
    }

    // KNN search using max-heap of size K for best neighbors
    void knn_search(const KDNode *node, double qlat, double qlon, int K, priority_queue<pair<double,int>> &maxheap) const {
        if (!node) return;
        const Point &p = data->at(node->idx);
        double d = haversine_distance_m(qlat, qlon, p.lat, p.lon);
        if ((int)maxheap.size() < K) {
            maxheap.push({d, node->idx});
        } else if (d < maxheap.top().first) {
            maxheap.pop();
            maxheap.push({d, node->idx});
        }
        int axis = node->axis;
        double diff = (axis == 0) ? (qlat - p.lat) : (qlon - p.lon);
        const KDNode *first = diff < 0 ? node->left : node->right;
        const KDNode *second = diff < 0 ? node->right : node->left;
        if (first) knn_search(first, qlat, qlon, K, maxheap);
        // Check if we need to visit other side
        double diffMeters;
        if (axis == 0) {
            // Convert degrees latitude difference to meters approx using 111km per degree
            diffMeters = fabs(diff) * 111000.0;
        } else {
            // longitude degree meters depends on latitude
            double latRad = deg2rad(qlat);
            double metersPerDegLon = 111000.0 * cos(latRad);
            diffMeters = fabs(diff) * metersPerDegLon;
        }
        if ((int)maxheap.size() < K || diffMeters < maxheap.top().first) {
            if (second) knn_search(second, qlat, qlon, K, maxheap);
        }
    }

    vector<Neighbor> knn_query(double qlat, double qlon, int K) const {
        vector<Neighbor> result;
        if (!root) return result;
        priority_queue<pair<double,int>> maxheap; // pair<dist, idx>
        knn_search(root, qlat, qlon, K, maxheap);
        while (!maxheap.empty()) {
            auto pr = maxheap.top(); maxheap.pop();
            result.push_back({pr.first, data->at(pr.second).label, data->at(pr.second).id});
        }
        // result is in descending distance; reverse it
        reverse(result.begin(), result.end());
        return result;
    }
};

// --------------------------- CSV Reader -----------------------------------

bool load_crime_csv(const string &filename, vector<Point> &out, string &err) {
    ifstream fin(filename);
    if (!fin.is_open()) { err = "Cannot open file: " + filename; return false; }
    string header;
    if (!getline(fin, header)) { err = "Empty file"; return false; }
    vector<string> cols;
    parse_csv_line(header, cols);
    // Determine indices of required columns; accept common names
    unordered_map<string,int> idx;
    for (int i=0;i<(int)cols.size();++i) {
        string name = cols[i];
        for (auto &c : name) c = tolower(c);
        trim(name);
        idx[name] = i;
    }
    // Lowercase keys mapping
    auto find_col = [&](const vector<string>& names)->int {
        for (auto &n : names) {
            string key = n;
            for (auto &c : key) c = tolower(c);
            if (idx.find(key) != idx.end()) return idx[key];
        }
        return -1;
    };
    int id_col = 0;
    int lat_col = find_col({"latitude","lat","y"});
    int lon_col = find_col({"longitude","lon","lng","x"});
    int label_col = find_col({"label","is_crime","crime","risk"});
    int severity_col = find_col({"severity"});
    int ts_col = find_col({"timestamp","time","ts"});

    if (lat_col == -1 || lon_col == -1) {
        err = "CSV must contain latitude and longitude columns.";
        return false;
    }
    // Default label column assumed 'label' else create from presence (if missing assume 1 for all)
    bool has_label = (label_col != -1);

    string line;
    int line_no = 1;
    while (getline(fin, line)) {
        ++line_no;
        if (line.empty()) continue;
        vector<string> fields;
        parse_csv_line(line, fields);
        if ((int)fields.size() <= max(lat_col, lon_col)) {
            cerr << "Warning: skipping malformed line " << line_no << "\n";
            continue;
        }
        Point p;
        p.id = (fields.size() > id_col) ? fields[id_col] : ("r" + to_string(line_no));
        try {
            p.lat = stod(fields[lat_col]);
            p.lon = stod(fields[lon_col]);
        } catch (...) {
            cerr << "Warning: invalid lat/lon at line " << line_no << ". Skipping.\n";
            continue;
        }
        if (has_label) {
            try { p.label = stoi(fields[label_col]); }
            catch (...) { p.label = 1; }
        } else {
            p.label = 1; // assume crime
        }
        if (severity_col != -1 && (int)fields.size() > severity_col) {
            try { p.severity = stoi(fields[severity_col]); } catch(...) { p.severity = 1; }
        } else p.severity = 1;
        if (ts_col != -1 && (int)fields.size() > ts_col) {
            try { p.timestamp = stol(fields[ts_col]); } catch(...) { p.timestamp = 0; }
        } else p.timestamp = 0;
        out.push_back(p);
    }
    fin.close();
    return true;
}

// --------------------------- Main and CLI ---------------------------------

void print_usage() {
    cerr << "Usage: knn_location_risk data.csv --mode [bruteforce|kdtree] --k K --query lat lon\n";
    cerr << "Options:\n";
    cerr << "  --mode    bruteforce (default) or kdtree\n";
    cerr << "  --k       number of neighbors (default 5)\n";
    cerr << "  --weight  voting weight: plain or inverse (default inverse)\n";
    cerr << "  --batch   batch query file with lines 'lat,lon'\n";
}

int main(int argc, char** argv) {
    if (argc < 2) { print_usage(); return 1; }
    string datafile = argv[1];
    string mode = "bruteforce";
    int K = 5;
    string weight = "inverse";
    bool batch_mode = false;
    string batch_file;

    // Simple CLI parsing
    for (int i=2;i<argc;++i) {
        string s = argv[i];
        if (s == "--mode" && i+1<argc) { mode = argv[++i]; }
        else if (s == "--k" && i+1<argc) { K = stoi(argv[++i]); }
        else if (s == "--weight" && i+1<argc) { weight = argv[++i]; }
        else if (s == "--batch" && i+1<argc) { batch_mode = true; batch_file = argv[++i]; }
        else if (s == "--help") { print_usage(); return 0; }
    }

    vector<Point> data;
    string err;
    cout << "Loading data from " << datafile << " ...\n";
    if (!load_crime_csv(datafile, data, err)) {
        cerr << "Error: " << err << "\n";
        return 1;
    }
    cout << "Loaded " << data.size() << " points.\n";

    // Build KD-tree if requested
    KDTree tree;
    if (mode == "kdtree") {
        cout << "Building KD-tree ...\n";
        tree.build(data);
        cout << "KD-tree built.\n";
    }

    auto classify_point = [&](double qlat, double qlon) -> pair<int, vector<Neighbor>> {
        vector<Neighbor> neighbors;
        if (mode == "kdtree") {
            neighbors = tree.knn_query(qlat, qlon, K);
        } else {
            neighbors = knn_bruteforce(data, qlat, qlon, K);
        }

        // Voting
        int label = 0;
        if (weight == "plain") label = majority_vote(neighbors);
        else {
            double frac = weighted_vote(neighbors);
            // Threshold 0.5
            label = (frac >= 0.5) ? 1 : 0;
        }
        return {label, neighbors};
    };

    if (batch_mode) {
        ifstream fin(batch_file);
        if (!fin.is_open()) { cerr << "Cannot open batch file\n"; return 1; }
        string line;
        while (getline(fin, line)) {
            vector<string> f; parse_csv_line(line, f);
            if (f.size() < 2) continue;
            double lat = stod(f[0]); double lon = stod(f[1]);
            auto res = classify_point(lat, lon);
            cout << lat << "," << lon << " => " << (res.first==1 ? "Risky" : "Safe") << "\n";
        }
        fin.close();
        return 0;
    }

    // Interactive single query
    cout << "Enter query latitude and longitude (or type 'exit'):\n";
    while (true) {
        cout << "> ";
        string line;
        if (!getline(cin, line)) break;
        trim(line);
        if (line.empty()) continue;
        if (line == "exit" || line == "quit") break;
        vector<string> parts; parse_csv_line(line, parts);
        if (parts.size() < 2) { cerr << "Please enter: lat,lon\n"; continue; }
        double qlat = stod(parts[0]);
        double qlon = stod(parts[1]);
        auto res = classify_point(qlat, qlon);
        int label = res.first;
        cout << (label==1 ? "Risky" : "Safe") << "\n";
        cout << "Nearest neighbors (dist meters, label, id):\n";
        for (const auto &n : res.second) {
            cout << "  " << fixed << setprecision(1) << n.dist << "m, label=" << n.label << ", id=" << n.id << "\n";
        }
    }

    return 0;
}
